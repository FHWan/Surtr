#include "matrix3.h"

/**********************************************************************************************************
*函 数 名: Matrix3_Add
*功能说明: 3维矩阵加法: c=a+b
*形    参: 矩阵a 矩阵b 矩阵c
*返 回 值: 无
**********************************************************************************************************/
void Matrix3_Add(float *a,float *b,float *c)
{
    uint8_t i,j;
    for (i=0; i<3; i++)
    {
        for (j=0; j<3; j++)
        {
            c[i*3+j] = a[i*3+j] + b[i*3+j];
        }
    }
}

/**********************************************************************************************************
*函 数 名: Matrix3_Sub
*功能说明: 3维矩阵减法: c=a-b
*形    参: 矩阵a 矩阵b 矩阵c
*返 回 值: 无
**********************************************************************************************************/
void Matrix3_Sub(float *a,float *b,float *c)
{
    uint8_t i,j;
    for (i=0; i<3; i++)
    {
        for (j=0; j<3; j++)
        {
            c[i*3+j] = a[i*3+j] - b[i*3+j];
        }
    }
}

/**********************************************************************************************************
*函 数 名: Matrix3_Mul
*功能说明: 3维矩阵乘法: c=a×b
*形    参: 矩阵a 矩阵b 矩阵c
*返 回 值: 无
**********************************************************************************************************/
void Matrix3_Mul(float *a,float *b,float *c)
{
    uint8_t i,j;
    for (i=0; i<3; i++)
    {
        for (j=0; j<3; j++)
        {
            c[i*3+j] = a[i*3+0] * b[0*3+j] + a[i*3+1] * b[1*3+j] + a[i*3+2] * b[2*3+j];
        }
    }
}
/**********************************************************************************************************
*函 数 名: Matrix3 * Matrix1
*功能说明: 三维矩阵乘列向量
*形    参: 矩阵a 矩阵b
*返 回 值: 无
**********************************************************************************************************/
void Matrix3_Mul_Matrix1(float *a,float *b, Vector3f_t *c)
{
	c->x = a[0] * b[0]  + a [1] * b[1] + a[2] * b[2];
	c->y = a[3] * b[0]  + a [4] * b[1] + a[5] * b[2];
	c->z = a[6] * b[0]  + a [7] * b[1] + a[8] * b[2];
}
/**********************************************************************************************************
*函 数 名: Matrix3_Copy
*功能说明: 3维矩阵复制： b=a
*形    参: 矩阵a 矩阵b
*返 回 值: 无
**********************************************************************************************************/
void Matrix3_Copy(float *a, float *b)
{
    uint8_t i;
    for(i=0; i<9; i++)
    {
        b[i] = a[i];
    }
}

/**********************************************************************************************************
*函 数 名: Matrix3_Tran
*功能说明: 3维矩阵求转置
*形    参: 矩阵a 矩阵b
*返 回 值: 无
**********************************************************************************************************/
void Matrix3_Tran(float *a, float *b)
{
    b[0] = a[0];
    b[1] = a[3];
    b[2] = a[6];
    b[3] = a[1];
    b[4] = a[4];
    b[5] = a[7];
    b[6] = a[2];
    b[7] = a[5];
    b[8] = a[8];
}

/**********************************************************************************************************
*函 数 名: Matrix3_Det
*功能说明: 3维矩阵求逆 b= aˉ1
*形    参: 矩阵a 矩阵b
*返 回 值: 无
**********************************************************************************************************/
void Matrix3_Det(float *a,float *b)
{
    float det;

    det = a[0] * a[4] * a[8]
          + a[1] * a[5] * a[6]
          + a[2] * a[3] * a[7]
          - a[2] * a[4] * a[6]
          - a[5] * a[7] * a[0]
          - a[8] * a[1] * a[3];

    b[0] = (a[4] * a[8] - a[5] * a[7]) / det;
    b[1] = (a[2] * a[7] - a[1] * a[8]) / det;
    b[2] = (a[1] * a[7] - a[4] * a[6]) / det;

    b[3] = (a[5] * a[6] - a[3] * a[8]) / det;
    b[4] = (a[0] * a[8] - a[2] * a[6]) / det;
    b[5] = (a[2] * a[3] - a[0] * a[5]) / det;

    b[6] = (a[3] * a[7] - a[4] * a[6]) / det;
    b[7] = (a[1] * a[6] - a[0] * a[7]) / det;
    b[8] = (a[0] * a[4] - a[1] * a[3]) / det;
}




#define EPSILON 8.8817841970012523e-016 /* 4.0 * DBL_EPSILON */
/*
Quaternion to rotation matrix.
*/
int quaternion_matrix(
    double *quat,    /* double[4]  */
    double *matrix)  /* double[16] */
{
    double *M = matrix;
    double *q = quat;
    double n = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);

    if (n < EPSILON) {
        /* return identity matrix */
        memset(M, 0, 16*sizeof(double));
        M[0] = M[5] = M[10] = M[15] = 1.0;
    } else {
        q[0] /= n;
        q[1] /= n;
        q[2] /= n;
        q[3] /= n;
        {
            double x2 = q[1]+q[1];
            double y2 = q[2]+q[2];
            double z2 = q[3]+q[3];
            {
                double xx2 = q[1]*x2;
                double yy2 = q[2]*y2;
                double zz2 = q[3]*z2;
                M[0]  = 1.0 - yy2 - zz2;
                M[5]  = 1.0 - xx2 - zz2;
                M[10] = 1.0 - xx2 - yy2;
            }{
                double yz2 = q[2]*z2;
                double wx2 = q[0]*x2;
                M[6] = yz2 - wx2;
                M[9] = yz2 + wx2;
            }{
                double xy2 = q[1]*y2;
                double wz2 = q[0]*z2;
                M[1] = xy2 - wz2;
                M[4] = xy2 + wz2;
            }{
                double xz2 = q[1]*z2;
                double wy2 = q[0]*y2;
                M[8] = xz2 - wy2;
                M[2] = xz2 + wy2;
            }
            M[3] = M[7] = M[11] = M[12] = M[13] = M[14] = 0.0;
            M[15] = 1.0;
        }
    }
    return 0;
}




